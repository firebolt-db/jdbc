package com.firebolt.jdbc.util;

import lombok.experimental.UtilityClass;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.Enumeration;
import java.util.Properties;
import java.util.jar.Attributes.Name;
import java.util.jar.Manifest;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@UtilityClass
public class VersionUtil {

	private static final Pattern VERSION_PATTERN = Pattern.compile("^\\s*(\\d+)\\.(\\d+).*");
	private static final String IMPLEMENTATION_TITLE = "Implementation-Title";
	private static final String IMPLEMENTATION_VERSION = "Implementation-Version";
	private static final String SPECIFICATION_VERSION = "Specification-Version";
	private static final String FIREBOLT_IMPLEMENTATION_TITLE = "Firebolt JDBC driver"; // This value must be the same as one defined in build.gradle/jar/manifest/attributes

	private static String driverVersion = "3.0.4";
	private static String specificationVersion = "4.3";
	private static final Logger log = Logger.getLogger(VersionUtil.class.getName());

	static {
		try {
			retrieveVersionInfo();
			log.log(Level.INFO, "Firebolt driver version used: {0}", driverVersion);
		} catch (IOException e) {
			log.log(Level.SEVERE, "Could not get Project Version defined in the build.gradle file", e);
		}
	}

	/**
	 * Does the best effort to retrieve the driver version.
	 * <ol>
	 *     <li>parse MANIFEST.MF loaded by the same class loader that was used for loading of this class.</li>
	 *     <li>Iterate over all MANIFEST.MF found in the classpath, identify correct manifest by its title "Firebolt JDBC driver" and parse it</li>
	 *     <li>get driver version only from version.properties if found</li>
	 *     <li>get driver and specification version from gradle.properties</li>
	 *     <li>use hard coded version values - the last fallback</li>
	 * </ol>
	 *
	 * Why this mechanism is so complicated? Theoretically, in single class loader application, the first mechanism must work.
	 * However, current class can be loaded by other class loader, so MANIFEST.MF will not be available there. In this case
	 * we do yet another attempt: iterate over all available for context class loader of current thread manifest files.
	 * This still may fail. So, we do yet another attempt: try to locate version.properties generated by the build.
	 * We also have here a patch for unit tests that run against not packaged classes when manifest is not created yet.
	 * This patch is implemented by using gradle.properties - the source of the current version, file that is manually
	 * updated when we want to move to the next version. This file however does not exist in production environment.
	 * The last fallback is hard coded driver and specification version. The specification version is being changed very
	 * seldom, so the chance that it will be wrong is low. Driver version is increased from time to time, so in worse
	 * case, if the real version is not found and developer forgot to update hard coded driver version together with one
	 * defined in the MANIFEST.MF (and sourced from the version.properties) the driver will report wrong version.
	 * It is not good but anyway better than returning null that can cause failure in some systems.
	 * In our case we saw problem in Tableau that throws {@link NullPointerException} in this case.
	 * ({@see <a href="https://packboard.atlassian.net/browse/FIR-30343">FIR-30343</a>})
	 *
	 * @throws IOException if something went really wrong
	 */
	private static void retrieveVersionInfo() throws IOException {
		if (retrieveVersionInfoFromManifest(VersionUtil.class.getResourceAsStream("/META-INF/MANIFEST.MF"))) {
			return;
		}
		for(Enumeration<URL> eurl = Thread.currentThread().getContextClassLoader().getResources("META-INF/MANIFEST.MF"); eurl.hasMoreElements();) {
			try (InputStream in = eurl.nextElement().openStream()) {
				if (retrieveVersionInfoFromManifest(in)) {
					return;
				}
			}
		}
		if (retrieveVersionInfoFromProperties(VersionUtil.class.getResourceAsStream("/version.properties"))) {
			return;
		}

		File gradleProperties = new File("gradle.properties"); // for testing environment
		if (gradleProperties.exists()) {
			try (InputStream in = new FileInputStream(gradleProperties)) {
				retrieveVersionInfoFromProperties(in);
			}
		}
	}

	private static boolean retrieveVersionInfoFromManifest(InputStream in) throws IOException {
		if (in == null) {
			return false;
		}
		Manifest manifest = new Manifest(in);
		String implementationTitle = (String)manifest.getMainAttributes().get(new Name(IMPLEMENTATION_TITLE));
		if (FIREBOLT_IMPLEMENTATION_TITLE.equals(implementationTitle)) {
			driverVersion = (String)manifest.getMainAttributes().get(new Name(IMPLEMENTATION_VERSION));
			specificationVersion = (String)manifest.getMainAttributes().get(new Name(SPECIFICATION_VERSION));
			return true;
		}
		return false;
	}

	private static boolean retrieveVersionInfoFromProperties(InputStream in) throws IOException {
		if (in == null) {
			return false;
		}
		Properties properties = new Properties();
		properties.load(in);
		driverVersion = properties.getProperty("version", driverVersion);
		specificationVersion = properties.getProperty("jdbcVersion", specificationVersion);
		return true;
	}

	/**
	 * Returns the driver major version
	 *
	 * @return the driver major version
	 */
	public int getMajorDriverVersion() {
		return extractMajorVersion(driverVersion);
	}

	/**
	 * Returns the driver minor version
	 *
	 * @return the driver minor version
	 */
	public int getDriverMinorVersion() {
		return extractMinorVersion(driverVersion);
	}

	/**
	 * Extracts the major version from the version provided
	 *
	 * @param version the version to extract the major version from
	 * @return the major version
	 */
	public int extractMajorVersion(String version) {
		if (version == null) {
			return 0;
		}
		Matcher matcher = VERSION_PATTERN.matcher(version);
		return matcher.matches() ? Integer.parseInt(matcher.group(1)) : 0;
	}

	/**
	 * Extracts the minor version from the version provided
	 *
	 * @param version the version to extract the minor version from
	 * @return the minor version
	 */
	public int extractMinorVersion(String version) {
		if (version == null) {
			return 0;
		}
		Matcher matcher = VERSION_PATTERN.matcher(version);
		return matcher.matches() ? Integer.parseInt(matcher.group(2)) : 0;
	}

	/**
	 * Returns the driver version
	 *
	 * @return the driver version
	 */
	public String getDriverVersion() {
		return driverVersion;
	}

	public String getSpecificationVersion() {
		return specificationVersion;
	}
}
